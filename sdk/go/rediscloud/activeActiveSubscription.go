// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rediscloud

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ActiveActiveSubscription struct {
	pulumi.CustomResourceState

	// A cloud provider string either GCP or AWS
	CloudProvider pulumi.StringPtrOutput `pulumi:"cloudProvider"`
	// Information about the planned databases used to optimise the database infrastructure. This information is only used when
	// creating a new subscription and any changes will be ignored after this.
	CreationPlan ActiveActiveSubscriptionCreationPlanPtrOutput `pulumi:"creationPlan"`
	// A meaningful name to identify the subscription
	Name pulumi.StringOutput `pulumi:"name"`
	// Payment method for the requested subscription. If credit card is specified, the payment method Id must be defined.
	PaymentMethod pulumi.StringPtrOutput `pulumi:"paymentMethod"`
	// A valid payment method pre-defined in the current account
	PaymentMethodId pulumi.StringOutput `pulumi:"paymentMethodId"`
}

// NewActiveActiveSubscription registers a new resource with the given unique name, arguments, and options.
func NewActiveActiveSubscription(ctx *pulumi.Context,
	name string, args *ActiveActiveSubscriptionArgs, opts ...pulumi.ResourceOption) (*ActiveActiveSubscription, error) {
	if args == nil {
		args = &ActiveActiveSubscriptionArgs{}
	}

	var resource ActiveActiveSubscription
	err := ctx.RegisterResource("rediscloud:index/activeActiveSubscription:ActiveActiveSubscription", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetActiveActiveSubscription gets an existing ActiveActiveSubscription resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetActiveActiveSubscription(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ActiveActiveSubscriptionState, opts ...pulumi.ResourceOption) (*ActiveActiveSubscription, error) {
	var resource ActiveActiveSubscription
	err := ctx.ReadResource("rediscloud:index/activeActiveSubscription:ActiveActiveSubscription", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ActiveActiveSubscription resources.
type activeActiveSubscriptionState struct {
	// A cloud provider string either GCP or AWS
	CloudProvider *string `pulumi:"cloudProvider"`
	// Information about the planned databases used to optimise the database infrastructure. This information is only used when
	// creating a new subscription and any changes will be ignored after this.
	CreationPlan *ActiveActiveSubscriptionCreationPlan `pulumi:"creationPlan"`
	// A meaningful name to identify the subscription
	Name *string `pulumi:"name"`
	// Payment method for the requested subscription. If credit card is specified, the payment method Id must be defined.
	PaymentMethod *string `pulumi:"paymentMethod"`
	// A valid payment method pre-defined in the current account
	PaymentMethodId *string `pulumi:"paymentMethodId"`
}

type ActiveActiveSubscriptionState struct {
	// A cloud provider string either GCP or AWS
	CloudProvider pulumi.StringPtrInput
	// Information about the planned databases used to optimise the database infrastructure. This information is only used when
	// creating a new subscription and any changes will be ignored after this.
	CreationPlan ActiveActiveSubscriptionCreationPlanPtrInput
	// A meaningful name to identify the subscription
	Name pulumi.StringPtrInput
	// Payment method for the requested subscription. If credit card is specified, the payment method Id must be defined.
	PaymentMethod pulumi.StringPtrInput
	// A valid payment method pre-defined in the current account
	PaymentMethodId pulumi.StringPtrInput
}

func (ActiveActiveSubscriptionState) ElementType() reflect.Type {
	return reflect.TypeOf((*activeActiveSubscriptionState)(nil)).Elem()
}

type activeActiveSubscriptionArgs struct {
	// A cloud provider string either GCP or AWS
	CloudProvider *string `pulumi:"cloudProvider"`
	// Information about the planned databases used to optimise the database infrastructure. This information is only used when
	// creating a new subscription and any changes will be ignored after this.
	CreationPlan *ActiveActiveSubscriptionCreationPlan `pulumi:"creationPlan"`
	// A meaningful name to identify the subscription
	Name *string `pulumi:"name"`
	// Payment method for the requested subscription. If credit card is specified, the payment method Id must be defined.
	PaymentMethod *string `pulumi:"paymentMethod"`
	// A valid payment method pre-defined in the current account
	PaymentMethodId *string `pulumi:"paymentMethodId"`
}

// The set of arguments for constructing a ActiveActiveSubscription resource.
type ActiveActiveSubscriptionArgs struct {
	// A cloud provider string either GCP or AWS
	CloudProvider pulumi.StringPtrInput
	// Information about the planned databases used to optimise the database infrastructure. This information is only used when
	// creating a new subscription and any changes will be ignored after this.
	CreationPlan ActiveActiveSubscriptionCreationPlanPtrInput
	// A meaningful name to identify the subscription
	Name pulumi.StringPtrInput
	// Payment method for the requested subscription. If credit card is specified, the payment method Id must be defined.
	PaymentMethod pulumi.StringPtrInput
	// A valid payment method pre-defined in the current account
	PaymentMethodId pulumi.StringPtrInput
}

func (ActiveActiveSubscriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*activeActiveSubscriptionArgs)(nil)).Elem()
}

type ActiveActiveSubscriptionInput interface {
	pulumi.Input

	ToActiveActiveSubscriptionOutput() ActiveActiveSubscriptionOutput
	ToActiveActiveSubscriptionOutputWithContext(ctx context.Context) ActiveActiveSubscriptionOutput
}

func (*ActiveActiveSubscription) ElementType() reflect.Type {
	return reflect.TypeOf((**ActiveActiveSubscription)(nil)).Elem()
}

func (i *ActiveActiveSubscription) ToActiveActiveSubscriptionOutput() ActiveActiveSubscriptionOutput {
	return i.ToActiveActiveSubscriptionOutputWithContext(context.Background())
}

func (i *ActiveActiveSubscription) ToActiveActiveSubscriptionOutputWithContext(ctx context.Context) ActiveActiveSubscriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActiveActiveSubscriptionOutput)
}

// ActiveActiveSubscriptionArrayInput is an input type that accepts ActiveActiveSubscriptionArray and ActiveActiveSubscriptionArrayOutput values.
// You can construct a concrete instance of `ActiveActiveSubscriptionArrayInput` via:
//
//	ActiveActiveSubscriptionArray{ ActiveActiveSubscriptionArgs{...} }
type ActiveActiveSubscriptionArrayInput interface {
	pulumi.Input

	ToActiveActiveSubscriptionArrayOutput() ActiveActiveSubscriptionArrayOutput
	ToActiveActiveSubscriptionArrayOutputWithContext(context.Context) ActiveActiveSubscriptionArrayOutput
}

type ActiveActiveSubscriptionArray []ActiveActiveSubscriptionInput

func (ActiveActiveSubscriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ActiveActiveSubscription)(nil)).Elem()
}

func (i ActiveActiveSubscriptionArray) ToActiveActiveSubscriptionArrayOutput() ActiveActiveSubscriptionArrayOutput {
	return i.ToActiveActiveSubscriptionArrayOutputWithContext(context.Background())
}

func (i ActiveActiveSubscriptionArray) ToActiveActiveSubscriptionArrayOutputWithContext(ctx context.Context) ActiveActiveSubscriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActiveActiveSubscriptionArrayOutput)
}

// ActiveActiveSubscriptionMapInput is an input type that accepts ActiveActiveSubscriptionMap and ActiveActiveSubscriptionMapOutput values.
// You can construct a concrete instance of `ActiveActiveSubscriptionMapInput` via:
//
//	ActiveActiveSubscriptionMap{ "key": ActiveActiveSubscriptionArgs{...} }
type ActiveActiveSubscriptionMapInput interface {
	pulumi.Input

	ToActiveActiveSubscriptionMapOutput() ActiveActiveSubscriptionMapOutput
	ToActiveActiveSubscriptionMapOutputWithContext(context.Context) ActiveActiveSubscriptionMapOutput
}

type ActiveActiveSubscriptionMap map[string]ActiveActiveSubscriptionInput

func (ActiveActiveSubscriptionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ActiveActiveSubscription)(nil)).Elem()
}

func (i ActiveActiveSubscriptionMap) ToActiveActiveSubscriptionMapOutput() ActiveActiveSubscriptionMapOutput {
	return i.ToActiveActiveSubscriptionMapOutputWithContext(context.Background())
}

func (i ActiveActiveSubscriptionMap) ToActiveActiveSubscriptionMapOutputWithContext(ctx context.Context) ActiveActiveSubscriptionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActiveActiveSubscriptionMapOutput)
}

type ActiveActiveSubscriptionOutput struct{ *pulumi.OutputState }

func (ActiveActiveSubscriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ActiveActiveSubscription)(nil)).Elem()
}

func (o ActiveActiveSubscriptionOutput) ToActiveActiveSubscriptionOutput() ActiveActiveSubscriptionOutput {
	return o
}

func (o ActiveActiveSubscriptionOutput) ToActiveActiveSubscriptionOutputWithContext(ctx context.Context) ActiveActiveSubscriptionOutput {
	return o
}

// A cloud provider string either GCP or AWS
func (o ActiveActiveSubscriptionOutput) CloudProvider() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ActiveActiveSubscription) pulumi.StringPtrOutput { return v.CloudProvider }).(pulumi.StringPtrOutput)
}

// Information about the planned databases used to optimise the database infrastructure. This information is only used when
// creating a new subscription and any changes will be ignored after this.
func (o ActiveActiveSubscriptionOutput) CreationPlan() ActiveActiveSubscriptionCreationPlanPtrOutput {
	return o.ApplyT(func(v *ActiveActiveSubscription) ActiveActiveSubscriptionCreationPlanPtrOutput { return v.CreationPlan }).(ActiveActiveSubscriptionCreationPlanPtrOutput)
}

// A meaningful name to identify the subscription
func (o ActiveActiveSubscriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ActiveActiveSubscription) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Payment method for the requested subscription. If credit card is specified, the payment method Id must be defined.
func (o ActiveActiveSubscriptionOutput) PaymentMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ActiveActiveSubscription) pulumi.StringPtrOutput { return v.PaymentMethod }).(pulumi.StringPtrOutput)
}

// A valid payment method pre-defined in the current account
func (o ActiveActiveSubscriptionOutput) PaymentMethodId() pulumi.StringOutput {
	return o.ApplyT(func(v *ActiveActiveSubscription) pulumi.StringOutput { return v.PaymentMethodId }).(pulumi.StringOutput)
}

type ActiveActiveSubscriptionArrayOutput struct{ *pulumi.OutputState }

func (ActiveActiveSubscriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ActiveActiveSubscription)(nil)).Elem()
}

func (o ActiveActiveSubscriptionArrayOutput) ToActiveActiveSubscriptionArrayOutput() ActiveActiveSubscriptionArrayOutput {
	return o
}

func (o ActiveActiveSubscriptionArrayOutput) ToActiveActiveSubscriptionArrayOutputWithContext(ctx context.Context) ActiveActiveSubscriptionArrayOutput {
	return o
}

func (o ActiveActiveSubscriptionArrayOutput) Index(i pulumi.IntInput) ActiveActiveSubscriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ActiveActiveSubscription {
		return vs[0].([]*ActiveActiveSubscription)[vs[1].(int)]
	}).(ActiveActiveSubscriptionOutput)
}

type ActiveActiveSubscriptionMapOutput struct{ *pulumi.OutputState }

func (ActiveActiveSubscriptionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ActiveActiveSubscription)(nil)).Elem()
}

func (o ActiveActiveSubscriptionMapOutput) ToActiveActiveSubscriptionMapOutput() ActiveActiveSubscriptionMapOutput {
	return o
}

func (o ActiveActiveSubscriptionMapOutput) ToActiveActiveSubscriptionMapOutputWithContext(ctx context.Context) ActiveActiveSubscriptionMapOutput {
	return o
}

func (o ActiveActiveSubscriptionMapOutput) MapIndex(k pulumi.StringInput) ActiveActiveSubscriptionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ActiveActiveSubscription {
		return vs[0].(map[string]*ActiveActiveSubscription)[vs[1].(string)]
	}).(ActiveActiveSubscriptionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ActiveActiveSubscriptionInput)(nil)).Elem(), &ActiveActiveSubscription{})
	pulumi.RegisterInputType(reflect.TypeOf((*ActiveActiveSubscriptionArrayInput)(nil)).Elem(), ActiveActiveSubscriptionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ActiveActiveSubscriptionMapInput)(nil)).Elem(), ActiveActiveSubscriptionMap{})
	pulumi.RegisterOutputType(ActiveActiveSubscriptionOutput{})
	pulumi.RegisterOutputType(ActiveActiveSubscriptionArrayOutput{})
	pulumi.RegisterOutputType(ActiveActiveSubscriptionMapOutput{})
}
