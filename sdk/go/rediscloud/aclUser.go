// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rediscloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/RedisLabs/pulumi-rediscloud/sdk/go/rediscloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Creates a User in your Redis Enterprise Cloud Account.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/RedisLabs/pulumi-rediscloud/sdk/go/rediscloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := rediscloud.NewAclUser(ctx, "user-resource", &rediscloud.AclUserArgs{
//				Role:     pulumi.Any(rediscloud_acl_role.RoleResource.Name),
//				Password: pulumi.String("mY.passw0rd"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// `rediscloud_acl_user` can be imported using the Identifier of the User, e.g.
//
// ```sh
//
//	$ pulumi import rediscloud:index/aclUser:AclUser user-resource 123456
//
// ```
type AclUser struct {
	pulumi.CustomResourceState

	// A meaningful name for the User. Must be unique.
	Name pulumi.StringOutput `pulumi:"name"`
	// The password for this ACL User. Must contain a lower-case letter, a
	// upper-case letter, a
	// number and a special character.
	Password pulumi.StringOutput `pulumi:"password"`
	// The name of the Role held by the User.
	Role pulumi.StringOutput `pulumi:"role"`
}

// NewAclUser registers a new resource with the given unique name, arguments, and options.
func NewAclUser(ctx *pulumi.Context,
	name string, args *AclUserArgs, opts ...pulumi.ResourceOption) (*AclUser, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Password == nil {
		return nil, errors.New("invalid value for required argument 'Password'")
	}
	if args.Role == nil {
		return nil, errors.New("invalid value for required argument 'Role'")
	}
	if args.Password != nil {
		args.Password = pulumi.ToSecret(args.Password).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"password",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AclUser
	err := ctx.RegisterResource("rediscloud:index/aclUser:AclUser", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAclUser gets an existing AclUser resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAclUser(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AclUserState, opts ...pulumi.ResourceOption) (*AclUser, error) {
	var resource AclUser
	err := ctx.ReadResource("rediscloud:index/aclUser:AclUser", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AclUser resources.
type aclUserState struct {
	// A meaningful name for the User. Must be unique.
	Name *string `pulumi:"name"`
	// The password for this ACL User. Must contain a lower-case letter, a
	// upper-case letter, a
	// number and a special character.
	Password *string `pulumi:"password"`
	// The name of the Role held by the User.
	Role *string `pulumi:"role"`
}

type AclUserState struct {
	// A meaningful name for the User. Must be unique.
	Name pulumi.StringPtrInput
	// The password for this ACL User. Must contain a lower-case letter, a
	// upper-case letter, a
	// number and a special character.
	Password pulumi.StringPtrInput
	// The name of the Role held by the User.
	Role pulumi.StringPtrInput
}

func (AclUserState) ElementType() reflect.Type {
	return reflect.TypeOf((*aclUserState)(nil)).Elem()
}

type aclUserArgs struct {
	// A meaningful name for the User. Must be unique.
	Name *string `pulumi:"name"`
	// The password for this ACL User. Must contain a lower-case letter, a
	// upper-case letter, a
	// number and a special character.
	Password string `pulumi:"password"`
	// The name of the Role held by the User.
	Role string `pulumi:"role"`
}

// The set of arguments for constructing a AclUser resource.
type AclUserArgs struct {
	// A meaningful name for the User. Must be unique.
	Name pulumi.StringPtrInput
	// The password for this ACL User. Must contain a lower-case letter, a
	// upper-case letter, a
	// number and a special character.
	Password pulumi.StringInput
	// The name of the Role held by the User.
	Role pulumi.StringInput
}

func (AclUserArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*aclUserArgs)(nil)).Elem()
}

type AclUserInput interface {
	pulumi.Input

	ToAclUserOutput() AclUserOutput
	ToAclUserOutputWithContext(ctx context.Context) AclUserOutput
}

func (*AclUser) ElementType() reflect.Type {
	return reflect.TypeOf((**AclUser)(nil)).Elem()
}

func (i *AclUser) ToAclUserOutput() AclUserOutput {
	return i.ToAclUserOutputWithContext(context.Background())
}

func (i *AclUser) ToAclUserOutputWithContext(ctx context.Context) AclUserOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclUserOutput)
}

func (i *AclUser) ToOutput(ctx context.Context) pulumix.Output[*AclUser] {
	return pulumix.Output[*AclUser]{
		OutputState: i.ToAclUserOutputWithContext(ctx).OutputState,
	}
}

// AclUserArrayInput is an input type that accepts AclUserArray and AclUserArrayOutput values.
// You can construct a concrete instance of `AclUserArrayInput` via:
//
//	AclUserArray{ AclUserArgs{...} }
type AclUserArrayInput interface {
	pulumi.Input

	ToAclUserArrayOutput() AclUserArrayOutput
	ToAclUserArrayOutputWithContext(context.Context) AclUserArrayOutput
}

type AclUserArray []AclUserInput

func (AclUserArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AclUser)(nil)).Elem()
}

func (i AclUserArray) ToAclUserArrayOutput() AclUserArrayOutput {
	return i.ToAclUserArrayOutputWithContext(context.Background())
}

func (i AclUserArray) ToAclUserArrayOutputWithContext(ctx context.Context) AclUserArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclUserArrayOutput)
}

func (i AclUserArray) ToOutput(ctx context.Context) pulumix.Output[[]*AclUser] {
	return pulumix.Output[[]*AclUser]{
		OutputState: i.ToAclUserArrayOutputWithContext(ctx).OutputState,
	}
}

// AclUserMapInput is an input type that accepts AclUserMap and AclUserMapOutput values.
// You can construct a concrete instance of `AclUserMapInput` via:
//
//	AclUserMap{ "key": AclUserArgs{...} }
type AclUserMapInput interface {
	pulumi.Input

	ToAclUserMapOutput() AclUserMapOutput
	ToAclUserMapOutputWithContext(context.Context) AclUserMapOutput
}

type AclUserMap map[string]AclUserInput

func (AclUserMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AclUser)(nil)).Elem()
}

func (i AclUserMap) ToAclUserMapOutput() AclUserMapOutput {
	return i.ToAclUserMapOutputWithContext(context.Background())
}

func (i AclUserMap) ToAclUserMapOutputWithContext(ctx context.Context) AclUserMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclUserMapOutput)
}

func (i AclUserMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*AclUser] {
	return pulumix.Output[map[string]*AclUser]{
		OutputState: i.ToAclUserMapOutputWithContext(ctx).OutputState,
	}
}

type AclUserOutput struct{ *pulumi.OutputState }

func (AclUserOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AclUser)(nil)).Elem()
}

func (o AclUserOutput) ToAclUserOutput() AclUserOutput {
	return o
}

func (o AclUserOutput) ToAclUserOutputWithContext(ctx context.Context) AclUserOutput {
	return o
}

func (o AclUserOutput) ToOutput(ctx context.Context) pulumix.Output[*AclUser] {
	return pulumix.Output[*AclUser]{
		OutputState: o.OutputState,
	}
}

// A meaningful name for the User. Must be unique.
func (o AclUserOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AclUser) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The password for this ACL User. Must contain a lower-case letter, a
// upper-case letter, a
// number and a special character.
func (o AclUserOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v *AclUser) pulumi.StringOutput { return v.Password }).(pulumi.StringOutput)
}

// The name of the Role held by the User.
func (o AclUserOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v *AclUser) pulumi.StringOutput { return v.Role }).(pulumi.StringOutput)
}

type AclUserArrayOutput struct{ *pulumi.OutputState }

func (AclUserArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AclUser)(nil)).Elem()
}

func (o AclUserArrayOutput) ToAclUserArrayOutput() AclUserArrayOutput {
	return o
}

func (o AclUserArrayOutput) ToAclUserArrayOutputWithContext(ctx context.Context) AclUserArrayOutput {
	return o
}

func (o AclUserArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*AclUser] {
	return pulumix.Output[[]*AclUser]{
		OutputState: o.OutputState,
	}
}

func (o AclUserArrayOutput) Index(i pulumi.IntInput) AclUserOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AclUser {
		return vs[0].([]*AclUser)[vs[1].(int)]
	}).(AclUserOutput)
}

type AclUserMapOutput struct{ *pulumi.OutputState }

func (AclUserMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AclUser)(nil)).Elem()
}

func (o AclUserMapOutput) ToAclUserMapOutput() AclUserMapOutput {
	return o
}

func (o AclUserMapOutput) ToAclUserMapOutputWithContext(ctx context.Context) AclUserMapOutput {
	return o
}

func (o AclUserMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*AclUser] {
	return pulumix.Output[map[string]*AclUser]{
		OutputState: o.OutputState,
	}
}

func (o AclUserMapOutput) MapIndex(k pulumi.StringInput) AclUserOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AclUser {
		return vs[0].(map[string]*AclUser)[vs[1].(string)]
	}).(AclUserOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AclUserInput)(nil)).Elem(), &AclUser{})
	pulumi.RegisterInputType(reflect.TypeOf((*AclUserArrayInput)(nil)).Elem(), AclUserArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AclUserMapInput)(nil)).Elem(), AclUserMap{})
	pulumi.RegisterOutputType(AclUserOutput{})
	pulumi.RegisterOutputType(AclUserArrayOutput{})
	pulumi.RegisterOutputType(AclUserMapOutput{})
}
