// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rediscloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates an AWS or GCP VPC peering for an existing Redis Enterprise Cloud Subscription, allowing access to your subscription databases as if they were on the same network.
//
// For AWS, peering should be accepted by the other side.
// For GCP, the opposite peering request should be submitted.
//
// ## Example Usage
// ### AWS
//
// The following example shows how a subscription can be peered with a AWS VPC using the rediscloud and google providers.
//
// ```go
// package main
//
// import (
//
//	"github.com/RedisLabs/pulumi-rediscloud/sdk/go/rediscloud"
//	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/ec2"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleSubscription, err := rediscloud.NewSubscription(ctx, "exampleSubscription", nil)
//			if err != nil {
//				return err
//			}
//			exampleSubscriptionPeering, err := rediscloud.NewSubscriptionPeering(ctx, "exampleSubscriptionPeering", &rediscloud.SubscriptionPeeringArgs{
//				SubscriptionId: exampleSubscription.ID(),
//				Region:         pulumi.String("eu-west-1"),
//				AwsAccountId:   pulumi.String("123456789012"),
//				VpcId:          pulumi.String("vpc-01234567890"),
//				VpcCidr:        pulumi.String("10.0.0.0/8"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = ec2.NewVpcPeeringConnectionAccepter(ctx, "example-peering", &ec2.VpcPeeringConnectionAccepterArgs{
//				VpcPeeringConnectionId: exampleSubscriptionPeering.AwsPeeringId,
//				AutoAccept:             pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### GCP
//
// The following example shows how a subscription can be peered with a GCP project network using the rediscloud and google providers.
// The example HCL locates the network details and creates/accepts the vpc peering connection through the Google provider.
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/RedisLabs/pulumi-rediscloud/sdk/go/rediscloud"
//	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := rediscloud.NewSubscription(ctx, "example", nil)
//			if err != nil {
//				return err
//			}
//			network, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
//				Project: pulumi.StringRef("my-gcp-project"),
//				Name:    "my-gcp-vpc",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = rediscloud.NewSubscriptionPeering(ctx, "example-peeringSubscriptionPeering", &rediscloud.SubscriptionPeeringArgs{
//				SubscriptionId: example.ID(),
//				ProviderName:   pulumi.String("GCP"),
//				GcpProjectId:   *pulumi.String(network.Project),
//				GcpNetworkName: *pulumi.String(network.Name),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = compute.NewNetworkPeering(ctx, "example-peeringNetworkPeering", &compute.NetworkPeeringArgs{
//				Network:     *pulumi.String(network.SelfLink),
//				PeerNetwork: pulumi.String(fmt.Sprintf("https://www.googleapis.com/compute/v1/projects/%v/global/networks/%v", rediscloud_subscription_peering.Example.Gcp_redis_project_id, rediscloud_subscription_peering.Example.Gcp_redis_network_name)),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// `rediscloud_subscription_peering` can be imported using the ID of the subscription and the ID of the peering connection, e.g.
//
// ```sh
//
//	$ pulumi import rediscloud:index/subscriptionPeering:SubscriptionPeering example 12345678/1234
//
// ```
type SubscriptionPeering struct {
	pulumi.CustomResourceState

	// AWS account ID that the VPC to be peered lives in
	AwsAccountId pulumi.StringOutput `pulumi:"awsAccountId"`
	// Identifier of the AWS cloud peering
	AwsPeeringId pulumi.StringOutput `pulumi:"awsPeeringId"`
	// The name of the network to be peered
	GcpNetworkName pulumi.StringOutput `pulumi:"gcpNetworkName"`
	// Identifier of the cloud peering
	GcpPeeringId pulumi.StringOutput `pulumi:"gcpPeeringId"`
	// GCP project ID that the VPC to be peered lives in
	GcpProjectId pulumi.StringOutput `pulumi:"gcpProjectId"`
	// The name of the Redis Enterprise Cloud network to be peered
	GcpRedisNetworkName pulumi.StringOutput `pulumi:"gcpRedisNetworkName"`
	// Identifier of the Redis Enterprise Cloud GCP project to be peered
	GcpRedisProjectId pulumi.StringOutput `pulumi:"gcpRedisProjectId"`
	// The cloud provider to use with the vpc peering, (either `AWS` or `GCP`). Default: ‘AWS’
	ProviderName pulumi.StringPtrOutput `pulumi:"providerName"`
	// AWS Region that the VPC to be peered lives in
	Region pulumi.StringOutput `pulumi:"region"`
	// is set to the current status of the peering - `initiating-request`, `pending-acceptance`, `active`, `inactive` or `failed`.
	Status pulumi.StringOutput `pulumi:"status"`
	// A valid subscription predefined in the current account
	SubscriptionId pulumi.StringOutput `pulumi:"subscriptionId"`
	// CIDR range of the VPC to be peered
	VpcCidr pulumi.StringOutput `pulumi:"vpcCidr"`
	// Identifier of the VPC to be peered
	VpcId pulumi.StringOutput `pulumi:"vpcId"`
}

// NewSubscriptionPeering registers a new resource with the given unique name, arguments, and options.
func NewSubscriptionPeering(ctx *pulumi.Context,
	name string, args *SubscriptionPeeringArgs, opts ...pulumi.ResourceOption) (*SubscriptionPeering, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SubscriptionId == nil {
		return nil, errors.New("invalid value for required argument 'SubscriptionId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource SubscriptionPeering
	err := ctx.RegisterResource("rediscloud:index/subscriptionPeering:SubscriptionPeering", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSubscriptionPeering gets an existing SubscriptionPeering resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSubscriptionPeering(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SubscriptionPeeringState, opts ...pulumi.ResourceOption) (*SubscriptionPeering, error) {
	var resource SubscriptionPeering
	err := ctx.ReadResource("rediscloud:index/subscriptionPeering:SubscriptionPeering", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SubscriptionPeering resources.
type subscriptionPeeringState struct {
	// AWS account ID that the VPC to be peered lives in
	AwsAccountId *string `pulumi:"awsAccountId"`
	// Identifier of the AWS cloud peering
	AwsPeeringId *string `pulumi:"awsPeeringId"`
	// The name of the network to be peered
	GcpNetworkName *string `pulumi:"gcpNetworkName"`
	// Identifier of the cloud peering
	GcpPeeringId *string `pulumi:"gcpPeeringId"`
	// GCP project ID that the VPC to be peered lives in
	GcpProjectId *string `pulumi:"gcpProjectId"`
	// The name of the Redis Enterprise Cloud network to be peered
	GcpRedisNetworkName *string `pulumi:"gcpRedisNetworkName"`
	// Identifier of the Redis Enterprise Cloud GCP project to be peered
	GcpRedisProjectId *string `pulumi:"gcpRedisProjectId"`
	// The cloud provider to use with the vpc peering, (either `AWS` or `GCP`). Default: ‘AWS’
	ProviderName *string `pulumi:"providerName"`
	// AWS Region that the VPC to be peered lives in
	Region *string `pulumi:"region"`
	// is set to the current status of the peering - `initiating-request`, `pending-acceptance`, `active`, `inactive` or `failed`.
	Status *string `pulumi:"status"`
	// A valid subscription predefined in the current account
	SubscriptionId *string `pulumi:"subscriptionId"`
	// CIDR range of the VPC to be peered
	VpcCidr *string `pulumi:"vpcCidr"`
	// Identifier of the VPC to be peered
	VpcId *string `pulumi:"vpcId"`
}

type SubscriptionPeeringState struct {
	// AWS account ID that the VPC to be peered lives in
	AwsAccountId pulumi.StringPtrInput
	// Identifier of the AWS cloud peering
	AwsPeeringId pulumi.StringPtrInput
	// The name of the network to be peered
	GcpNetworkName pulumi.StringPtrInput
	// Identifier of the cloud peering
	GcpPeeringId pulumi.StringPtrInput
	// GCP project ID that the VPC to be peered lives in
	GcpProjectId pulumi.StringPtrInput
	// The name of the Redis Enterprise Cloud network to be peered
	GcpRedisNetworkName pulumi.StringPtrInput
	// Identifier of the Redis Enterprise Cloud GCP project to be peered
	GcpRedisProjectId pulumi.StringPtrInput
	// The cloud provider to use with the vpc peering, (either `AWS` or `GCP`). Default: ‘AWS’
	ProviderName pulumi.StringPtrInput
	// AWS Region that the VPC to be peered lives in
	Region pulumi.StringPtrInput
	// is set to the current status of the peering - `initiating-request`, `pending-acceptance`, `active`, `inactive` or `failed`.
	Status pulumi.StringPtrInput
	// A valid subscription predefined in the current account
	SubscriptionId pulumi.StringPtrInput
	// CIDR range of the VPC to be peered
	VpcCidr pulumi.StringPtrInput
	// Identifier of the VPC to be peered
	VpcId pulumi.StringPtrInput
}

func (SubscriptionPeeringState) ElementType() reflect.Type {
	return reflect.TypeOf((*subscriptionPeeringState)(nil)).Elem()
}

type subscriptionPeeringArgs struct {
	// AWS account ID that the VPC to be peered lives in
	AwsAccountId *string `pulumi:"awsAccountId"`
	// The name of the network to be peered
	GcpNetworkName *string `pulumi:"gcpNetworkName"`
	// GCP project ID that the VPC to be peered lives in
	GcpProjectId *string `pulumi:"gcpProjectId"`
	// The cloud provider to use with the vpc peering, (either `AWS` or `GCP`). Default: ‘AWS’
	ProviderName *string `pulumi:"providerName"`
	// AWS Region that the VPC to be peered lives in
	Region *string `pulumi:"region"`
	// A valid subscription predefined in the current account
	SubscriptionId string `pulumi:"subscriptionId"`
	// CIDR range of the VPC to be peered
	VpcCidr *string `pulumi:"vpcCidr"`
	// Identifier of the VPC to be peered
	VpcId *string `pulumi:"vpcId"`
}

// The set of arguments for constructing a SubscriptionPeering resource.
type SubscriptionPeeringArgs struct {
	// AWS account ID that the VPC to be peered lives in
	AwsAccountId pulumi.StringPtrInput
	// The name of the network to be peered
	GcpNetworkName pulumi.StringPtrInput
	// GCP project ID that the VPC to be peered lives in
	GcpProjectId pulumi.StringPtrInput
	// The cloud provider to use with the vpc peering, (either `AWS` or `GCP`). Default: ‘AWS’
	ProviderName pulumi.StringPtrInput
	// AWS Region that the VPC to be peered lives in
	Region pulumi.StringPtrInput
	// A valid subscription predefined in the current account
	SubscriptionId pulumi.StringInput
	// CIDR range of the VPC to be peered
	VpcCidr pulumi.StringPtrInput
	// Identifier of the VPC to be peered
	VpcId pulumi.StringPtrInput
}

func (SubscriptionPeeringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*subscriptionPeeringArgs)(nil)).Elem()
}

type SubscriptionPeeringInput interface {
	pulumi.Input

	ToSubscriptionPeeringOutput() SubscriptionPeeringOutput
	ToSubscriptionPeeringOutputWithContext(ctx context.Context) SubscriptionPeeringOutput
}

func (*SubscriptionPeering) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionPeering)(nil)).Elem()
}

func (i *SubscriptionPeering) ToSubscriptionPeeringOutput() SubscriptionPeeringOutput {
	return i.ToSubscriptionPeeringOutputWithContext(context.Background())
}

func (i *SubscriptionPeering) ToSubscriptionPeeringOutputWithContext(ctx context.Context) SubscriptionPeeringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionPeeringOutput)
}

// SubscriptionPeeringArrayInput is an input type that accepts SubscriptionPeeringArray and SubscriptionPeeringArrayOutput values.
// You can construct a concrete instance of `SubscriptionPeeringArrayInput` via:
//
//	SubscriptionPeeringArray{ SubscriptionPeeringArgs{...} }
type SubscriptionPeeringArrayInput interface {
	pulumi.Input

	ToSubscriptionPeeringArrayOutput() SubscriptionPeeringArrayOutput
	ToSubscriptionPeeringArrayOutputWithContext(context.Context) SubscriptionPeeringArrayOutput
}

type SubscriptionPeeringArray []SubscriptionPeeringInput

func (SubscriptionPeeringArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SubscriptionPeering)(nil)).Elem()
}

func (i SubscriptionPeeringArray) ToSubscriptionPeeringArrayOutput() SubscriptionPeeringArrayOutput {
	return i.ToSubscriptionPeeringArrayOutputWithContext(context.Background())
}

func (i SubscriptionPeeringArray) ToSubscriptionPeeringArrayOutputWithContext(ctx context.Context) SubscriptionPeeringArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionPeeringArrayOutput)
}

// SubscriptionPeeringMapInput is an input type that accepts SubscriptionPeeringMap and SubscriptionPeeringMapOutput values.
// You can construct a concrete instance of `SubscriptionPeeringMapInput` via:
//
//	SubscriptionPeeringMap{ "key": SubscriptionPeeringArgs{...} }
type SubscriptionPeeringMapInput interface {
	pulumi.Input

	ToSubscriptionPeeringMapOutput() SubscriptionPeeringMapOutput
	ToSubscriptionPeeringMapOutputWithContext(context.Context) SubscriptionPeeringMapOutput
}

type SubscriptionPeeringMap map[string]SubscriptionPeeringInput

func (SubscriptionPeeringMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SubscriptionPeering)(nil)).Elem()
}

func (i SubscriptionPeeringMap) ToSubscriptionPeeringMapOutput() SubscriptionPeeringMapOutput {
	return i.ToSubscriptionPeeringMapOutputWithContext(context.Background())
}

func (i SubscriptionPeeringMap) ToSubscriptionPeeringMapOutputWithContext(ctx context.Context) SubscriptionPeeringMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionPeeringMapOutput)
}

type SubscriptionPeeringOutput struct{ *pulumi.OutputState }

func (SubscriptionPeeringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionPeering)(nil)).Elem()
}

func (o SubscriptionPeeringOutput) ToSubscriptionPeeringOutput() SubscriptionPeeringOutput {
	return o
}

func (o SubscriptionPeeringOutput) ToSubscriptionPeeringOutputWithContext(ctx context.Context) SubscriptionPeeringOutput {
	return o
}

// AWS account ID that the VPC to be peered lives in
func (o SubscriptionPeeringOutput) AwsAccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.AwsAccountId }).(pulumi.StringOutput)
}

// Identifier of the AWS cloud peering
func (o SubscriptionPeeringOutput) AwsPeeringId() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.AwsPeeringId }).(pulumi.StringOutput)
}

// The name of the network to be peered
func (o SubscriptionPeeringOutput) GcpNetworkName() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.GcpNetworkName }).(pulumi.StringOutput)
}

// Identifier of the cloud peering
func (o SubscriptionPeeringOutput) GcpPeeringId() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.GcpPeeringId }).(pulumi.StringOutput)
}

// GCP project ID that the VPC to be peered lives in
func (o SubscriptionPeeringOutput) GcpProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.GcpProjectId }).(pulumi.StringOutput)
}

// The name of the Redis Enterprise Cloud network to be peered
func (o SubscriptionPeeringOutput) GcpRedisNetworkName() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.GcpRedisNetworkName }).(pulumi.StringOutput)
}

// Identifier of the Redis Enterprise Cloud GCP project to be peered
func (o SubscriptionPeeringOutput) GcpRedisProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.GcpRedisProjectId }).(pulumi.StringOutput)
}

// The cloud provider to use with the vpc peering, (either `AWS` or `GCP`). Default: ‘AWS’
func (o SubscriptionPeeringOutput) ProviderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringPtrOutput { return v.ProviderName }).(pulumi.StringPtrOutput)
}

// AWS Region that the VPC to be peered lives in
func (o SubscriptionPeeringOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// is set to the current status of the peering - `initiating-request`, `pending-acceptance`, `active`, `inactive` or `failed`.
func (o SubscriptionPeeringOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// A valid subscription predefined in the current account
func (o SubscriptionPeeringOutput) SubscriptionId() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.SubscriptionId }).(pulumi.StringOutput)
}

// CIDR range of the VPC to be peered
func (o SubscriptionPeeringOutput) VpcCidr() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.VpcCidr }).(pulumi.StringOutput)
}

// Identifier of the VPC to be peered
func (o SubscriptionPeeringOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v *SubscriptionPeering) pulumi.StringOutput { return v.VpcId }).(pulumi.StringOutput)
}

type SubscriptionPeeringArrayOutput struct{ *pulumi.OutputState }

func (SubscriptionPeeringArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SubscriptionPeering)(nil)).Elem()
}

func (o SubscriptionPeeringArrayOutput) ToSubscriptionPeeringArrayOutput() SubscriptionPeeringArrayOutput {
	return o
}

func (o SubscriptionPeeringArrayOutput) ToSubscriptionPeeringArrayOutputWithContext(ctx context.Context) SubscriptionPeeringArrayOutput {
	return o
}

func (o SubscriptionPeeringArrayOutput) Index(i pulumi.IntInput) SubscriptionPeeringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SubscriptionPeering {
		return vs[0].([]*SubscriptionPeering)[vs[1].(int)]
	}).(SubscriptionPeeringOutput)
}

type SubscriptionPeeringMapOutput struct{ *pulumi.OutputState }

func (SubscriptionPeeringMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SubscriptionPeering)(nil)).Elem()
}

func (o SubscriptionPeeringMapOutput) ToSubscriptionPeeringMapOutput() SubscriptionPeeringMapOutput {
	return o
}

func (o SubscriptionPeeringMapOutput) ToSubscriptionPeeringMapOutputWithContext(ctx context.Context) SubscriptionPeeringMapOutput {
	return o
}

func (o SubscriptionPeeringMapOutput) MapIndex(k pulumi.StringInput) SubscriptionPeeringOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SubscriptionPeering {
		return vs[0].(map[string]*SubscriptionPeering)[vs[1].(string)]
	}).(SubscriptionPeeringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionPeeringInput)(nil)).Elem(), &SubscriptionPeering{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionPeeringArrayInput)(nil)).Elem(), SubscriptionPeeringArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionPeeringMapInput)(nil)).Elem(), SubscriptionPeeringMap{})
	pulumi.RegisterOutputType(SubscriptionPeeringOutput{})
	pulumi.RegisterOutputType(SubscriptionPeeringArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionPeeringMapOutput{})
}
