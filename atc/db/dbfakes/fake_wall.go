// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"github.com/concourse/concourse/atc/db"
)

type FakeWall struct {
	ClearStub        func() error
	clearMutex       sync.RWMutex
	clearArgsForCall []struct {
	}
	clearReturns struct {
		result1 error
	}
	clearReturnsOnCall map[int]struct {
		result1 error
	}
	GetExpirationStub        func() (time.Time, error)
	getExpirationMutex       sync.RWMutex
	getExpirationArgsForCall []struct {
	}
	getExpirationReturns struct {
		result1 time.Time
		result2 error
	}
	getExpirationReturnsOnCall map[int]struct {
		result1 time.Time
		result2 error
	}
	GetMessageStub        func() (string, error)
	getMessageMutex       sync.RWMutex
	getMessageArgsForCall []struct {
	}
	getMessageReturns struct {
		result1 string
		result2 error
	}
	getMessageReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetExpirationStub        func(time.Duration) error
	setExpirationMutex       sync.RWMutex
	setExpirationArgsForCall []struct {
		arg1 time.Duration
	}
	setExpirationReturns struct {
		result1 error
	}
	setExpirationReturnsOnCall map[int]struct {
		result1 error
	}
	SetMessageStub        func(string) error
	setMessageMutex       sync.RWMutex
	setMessageArgsForCall []struct {
		arg1 string
	}
	setMessageReturns struct {
		result1 error
	}
	setMessageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWall) Clear() error {
	fake.clearMutex.Lock()
	ret, specificReturn := fake.clearReturnsOnCall[len(fake.clearArgsForCall)]
	fake.clearArgsForCall = append(fake.clearArgsForCall, struct {
	}{})
	fake.recordInvocation("Clear", []interface{}{})
	fake.clearMutex.Unlock()
	if fake.ClearStub != nil {
		return fake.ClearStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clearReturns
	return fakeReturns.result1
}

func (fake *FakeWall) ClearCallCount() int {
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	return len(fake.clearArgsForCall)
}

func (fake *FakeWall) ClearCalls(stub func() error) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = stub
}

func (fake *FakeWall) ClearReturns(result1 error) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = nil
	fake.clearReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWall) ClearReturnsOnCall(i int, result1 error) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = nil
	if fake.clearReturnsOnCall == nil {
		fake.clearReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWall) GetExpiration() (time.Time, error) {
	fake.getExpirationMutex.Lock()
	ret, specificReturn := fake.getExpirationReturnsOnCall[len(fake.getExpirationArgsForCall)]
	fake.getExpirationArgsForCall = append(fake.getExpirationArgsForCall, struct {
	}{})
	fake.recordInvocation("GetExpiration", []interface{}{})
	fake.getExpirationMutex.Unlock()
	if fake.GetExpirationStub != nil {
		return fake.GetExpirationStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getExpirationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWall) GetExpirationCallCount() int {
	fake.getExpirationMutex.RLock()
	defer fake.getExpirationMutex.RUnlock()
	return len(fake.getExpirationArgsForCall)
}

func (fake *FakeWall) GetExpirationCalls(stub func() (time.Time, error)) {
	fake.getExpirationMutex.Lock()
	defer fake.getExpirationMutex.Unlock()
	fake.GetExpirationStub = stub
}

func (fake *FakeWall) GetExpirationReturns(result1 time.Time, result2 error) {
	fake.getExpirationMutex.Lock()
	defer fake.getExpirationMutex.Unlock()
	fake.GetExpirationStub = nil
	fake.getExpirationReturns = struct {
		result1 time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeWall) GetExpirationReturnsOnCall(i int, result1 time.Time, result2 error) {
	fake.getExpirationMutex.Lock()
	defer fake.getExpirationMutex.Unlock()
	fake.GetExpirationStub = nil
	if fake.getExpirationReturnsOnCall == nil {
		fake.getExpirationReturnsOnCall = make(map[int]struct {
			result1 time.Time
			result2 error
		})
	}
	fake.getExpirationReturnsOnCall[i] = struct {
		result1 time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeWall) GetMessage() (string, error) {
	fake.getMessageMutex.Lock()
	ret, specificReturn := fake.getMessageReturnsOnCall[len(fake.getMessageArgsForCall)]
	fake.getMessageArgsForCall = append(fake.getMessageArgsForCall, struct {
	}{})
	fake.recordInvocation("GetMessage", []interface{}{})
	fake.getMessageMutex.Unlock()
	if fake.GetMessageStub != nil {
		return fake.GetMessageStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getMessageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWall) GetMessageCallCount() int {
	fake.getMessageMutex.RLock()
	defer fake.getMessageMutex.RUnlock()
	return len(fake.getMessageArgsForCall)
}

func (fake *FakeWall) GetMessageCalls(stub func() (string, error)) {
	fake.getMessageMutex.Lock()
	defer fake.getMessageMutex.Unlock()
	fake.GetMessageStub = stub
}

func (fake *FakeWall) GetMessageReturns(result1 string, result2 error) {
	fake.getMessageMutex.Lock()
	defer fake.getMessageMutex.Unlock()
	fake.GetMessageStub = nil
	fake.getMessageReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeWall) GetMessageReturnsOnCall(i int, result1 string, result2 error) {
	fake.getMessageMutex.Lock()
	defer fake.getMessageMutex.Unlock()
	fake.GetMessageStub = nil
	if fake.getMessageReturnsOnCall == nil {
		fake.getMessageReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getMessageReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeWall) SetExpiration(arg1 time.Duration) error {
	fake.setExpirationMutex.Lock()
	ret, specificReturn := fake.setExpirationReturnsOnCall[len(fake.setExpirationArgsForCall)]
	fake.setExpirationArgsForCall = append(fake.setExpirationArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("SetExpiration", []interface{}{arg1})
	fake.setExpirationMutex.Unlock()
	if fake.SetExpirationStub != nil {
		return fake.SetExpirationStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setExpirationReturns
	return fakeReturns.result1
}

func (fake *FakeWall) SetExpirationCallCount() int {
	fake.setExpirationMutex.RLock()
	defer fake.setExpirationMutex.RUnlock()
	return len(fake.setExpirationArgsForCall)
}

func (fake *FakeWall) SetExpirationCalls(stub func(time.Duration) error) {
	fake.setExpirationMutex.Lock()
	defer fake.setExpirationMutex.Unlock()
	fake.SetExpirationStub = stub
}

func (fake *FakeWall) SetExpirationArgsForCall(i int) time.Duration {
	fake.setExpirationMutex.RLock()
	defer fake.setExpirationMutex.RUnlock()
	argsForCall := fake.setExpirationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWall) SetExpirationReturns(result1 error) {
	fake.setExpirationMutex.Lock()
	defer fake.setExpirationMutex.Unlock()
	fake.SetExpirationStub = nil
	fake.setExpirationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWall) SetExpirationReturnsOnCall(i int, result1 error) {
	fake.setExpirationMutex.Lock()
	defer fake.setExpirationMutex.Unlock()
	fake.SetExpirationStub = nil
	if fake.setExpirationReturnsOnCall == nil {
		fake.setExpirationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setExpirationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWall) SetMessage(arg1 string) error {
	fake.setMessageMutex.Lock()
	ret, specificReturn := fake.setMessageReturnsOnCall[len(fake.setMessageArgsForCall)]
	fake.setMessageArgsForCall = append(fake.setMessageArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetMessage", []interface{}{arg1})
	fake.setMessageMutex.Unlock()
	if fake.SetMessageStub != nil {
		return fake.SetMessageStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setMessageReturns
	return fakeReturns.result1
}

func (fake *FakeWall) SetMessageCallCount() int {
	fake.setMessageMutex.RLock()
	defer fake.setMessageMutex.RUnlock()
	return len(fake.setMessageArgsForCall)
}

func (fake *FakeWall) SetMessageCalls(stub func(string) error) {
	fake.setMessageMutex.Lock()
	defer fake.setMessageMutex.Unlock()
	fake.SetMessageStub = stub
}

func (fake *FakeWall) SetMessageArgsForCall(i int) string {
	fake.setMessageMutex.RLock()
	defer fake.setMessageMutex.RUnlock()
	argsForCall := fake.setMessageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWall) SetMessageReturns(result1 error) {
	fake.setMessageMutex.Lock()
	defer fake.setMessageMutex.Unlock()
	fake.SetMessageStub = nil
	fake.setMessageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWall) SetMessageReturnsOnCall(i int, result1 error) {
	fake.setMessageMutex.Lock()
	defer fake.setMessageMutex.Unlock()
	fake.SetMessageStub = nil
	if fake.setMessageReturnsOnCall == nil {
		fake.setMessageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMessageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWall) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	fake.getExpirationMutex.RLock()
	defer fake.getExpirationMutex.RUnlock()
	fake.getMessageMutex.RLock()
	defer fake.getMessageMutex.RUnlock()
	fake.setExpirationMutex.RLock()
	defer fake.setExpirationMutex.RUnlock()
	fake.setMessageMutex.RLock()
	defer fake.setMessageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWall) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Wall = new(FakeWall)
