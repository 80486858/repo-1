// Code generated by counterfeiter. DO NOT EDIT.
package emitterfakes

import (
	"sync"

	"github.com/concourse/concourse/atc/metric/emitter"
	"github.com/prometheus/client_golang/prometheus"
)

type FakePrometheusGarbageCollectable struct {
	ContainerJobCollectorLabelsStub        func() map[string]map[string]prometheus.Labels
	containerJobCollectorLabelsMutex       sync.RWMutex
	containerJobCollectorLabelsArgsForCall []struct {
	}
	containerJobCollectorLabelsReturns struct {
		result1 map[string]map[string]prometheus.Labels
	}
	containerJobCollectorLabelsReturnsOnCall map[int]struct {
		result1 map[string]map[string]prometheus.Labels
	}
	DroppedContainerStub        func() *prometheus.GaugeVec
	droppedContainerMutex       sync.RWMutex
	droppedContainerArgsForCall []struct {
	}
	droppedContainerReturns struct {
		result1 *prometheus.GaugeVec
	}
	droppedContainerReturnsOnCall map[int]struct {
		result1 *prometheus.GaugeVec
	}
	WorkerContainersStub        func() *prometheus.GaugeVec
	workerContainersMutex       sync.RWMutex
	workerContainersArgsForCall []struct {
	}
	workerContainersReturns struct {
		result1 *prometheus.GaugeVec
	}
	workerContainersReturnsOnCall map[int]struct {
		result1 *prometheus.GaugeVec
	}
	WorkerContainersLabelsStub        func() map[string]map[string]prometheus.Labels
	workerContainersLabelsMutex       sync.RWMutex
	workerContainersLabelsArgsForCall []struct {
	}
	workerContainersLabelsReturns struct {
		result1 map[string]map[string]prometheus.Labels
	}
	workerContainersLabelsReturnsOnCall map[int]struct {
		result1 map[string]map[string]prometheus.Labels
	}
	WorkerTasksStub        func() *prometheus.GaugeVec
	workerTasksMutex       sync.RWMutex
	workerTasksArgsForCall []struct {
	}
	workerTasksReturns struct {
		result1 *prometheus.GaugeVec
	}
	workerTasksReturnsOnCall map[int]struct {
		result1 *prometheus.GaugeVec
	}
	WorkerTasksLabelsStub        func() map[string]map[string]prometheus.Labels
	workerTasksLabelsMutex       sync.RWMutex
	workerTasksLabelsArgsForCall []struct {
	}
	workerTasksLabelsReturns struct {
		result1 map[string]map[string]prometheus.Labels
	}
	workerTasksLabelsReturnsOnCall map[int]struct {
		result1 map[string]map[string]prometheus.Labels
	}
	WorkerVolumesStub        func() *prometheus.GaugeVec
	workerVolumesMutex       sync.RWMutex
	workerVolumesArgsForCall []struct {
	}
	workerVolumesReturns struct {
		result1 *prometheus.GaugeVec
	}
	workerVolumesReturnsOnCall map[int]struct {
		result1 *prometheus.GaugeVec
	}
	WorkerVolumesLabelsStub        func() map[string]map[string]prometheus.Labels
	workerVolumesLabelsMutex       sync.RWMutex
	workerVolumesLabelsArgsForCall []struct {
	}
	workerVolumesLabelsReturns struct {
		result1 map[string]map[string]prometheus.Labels
	}
	workerVolumesLabelsReturnsOnCall map[int]struct {
		result1 map[string]map[string]prometheus.Labels
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePrometheusGarbageCollectable) ContainerJobCollectorLabels() map[string]map[string]prometheus.Labels {
	fake.containerJobCollectorLabelsMutex.Lock()
	ret, specificReturn := fake.containerJobCollectorLabelsReturnsOnCall[len(fake.containerJobCollectorLabelsArgsForCall)]
	fake.containerJobCollectorLabelsArgsForCall = append(fake.containerJobCollectorLabelsArgsForCall, struct {
	}{})
	stub := fake.ContainerJobCollectorLabelsStub
	fakeReturns := fake.containerJobCollectorLabelsReturns
	fake.recordInvocation("ContainerJobCollectorLabels", []interface{}{})
	fake.containerJobCollectorLabelsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrometheusGarbageCollectable) ContainerJobCollectorLabelsCallCount() int {
	fake.containerJobCollectorLabelsMutex.RLock()
	defer fake.containerJobCollectorLabelsMutex.RUnlock()
	return len(fake.containerJobCollectorLabelsArgsForCall)
}

func (fake *FakePrometheusGarbageCollectable) ContainerJobCollectorLabelsCalls(stub func() map[string]map[string]prometheus.Labels) {
	fake.containerJobCollectorLabelsMutex.Lock()
	defer fake.containerJobCollectorLabelsMutex.Unlock()
	fake.ContainerJobCollectorLabelsStub = stub
}

func (fake *FakePrometheusGarbageCollectable) ContainerJobCollectorLabelsReturns(result1 map[string]map[string]prometheus.Labels) {
	fake.containerJobCollectorLabelsMutex.Lock()
	defer fake.containerJobCollectorLabelsMutex.Unlock()
	fake.ContainerJobCollectorLabelsStub = nil
	fake.containerJobCollectorLabelsReturns = struct {
		result1 map[string]map[string]prometheus.Labels
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) ContainerJobCollectorLabelsReturnsOnCall(i int, result1 map[string]map[string]prometheus.Labels) {
	fake.containerJobCollectorLabelsMutex.Lock()
	defer fake.containerJobCollectorLabelsMutex.Unlock()
	fake.ContainerJobCollectorLabelsStub = nil
	if fake.containerJobCollectorLabelsReturnsOnCall == nil {
		fake.containerJobCollectorLabelsReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]prometheus.Labels
		})
	}
	fake.containerJobCollectorLabelsReturnsOnCall[i] = struct {
		result1 map[string]map[string]prometheus.Labels
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) DroppedContainer() *prometheus.GaugeVec {
	fake.droppedContainerMutex.Lock()
	ret, specificReturn := fake.droppedContainerReturnsOnCall[len(fake.droppedContainerArgsForCall)]
	fake.droppedContainerArgsForCall = append(fake.droppedContainerArgsForCall, struct {
	}{})
	stub := fake.DroppedContainerStub
	fakeReturns := fake.droppedContainerReturns
	fake.recordInvocation("DroppedContainer", []interface{}{})
	fake.droppedContainerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrometheusGarbageCollectable) DroppedContainerCallCount() int {
	fake.droppedContainerMutex.RLock()
	defer fake.droppedContainerMutex.RUnlock()
	return len(fake.droppedContainerArgsForCall)
}

func (fake *FakePrometheusGarbageCollectable) DroppedContainerCalls(stub func() *prometheus.GaugeVec) {
	fake.droppedContainerMutex.Lock()
	defer fake.droppedContainerMutex.Unlock()
	fake.DroppedContainerStub = stub
}

func (fake *FakePrometheusGarbageCollectable) DroppedContainerReturns(result1 *prometheus.GaugeVec) {
	fake.droppedContainerMutex.Lock()
	defer fake.droppedContainerMutex.Unlock()
	fake.DroppedContainerStub = nil
	fake.droppedContainerReturns = struct {
		result1 *prometheus.GaugeVec
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) DroppedContainerReturnsOnCall(i int, result1 *prometheus.GaugeVec) {
	fake.droppedContainerMutex.Lock()
	defer fake.droppedContainerMutex.Unlock()
	fake.DroppedContainerStub = nil
	if fake.droppedContainerReturnsOnCall == nil {
		fake.droppedContainerReturnsOnCall = make(map[int]struct {
			result1 *prometheus.GaugeVec
		})
	}
	fake.droppedContainerReturnsOnCall[i] = struct {
		result1 *prometheus.GaugeVec
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainers() *prometheus.GaugeVec {
	fake.workerContainersMutex.Lock()
	ret, specificReturn := fake.workerContainersReturnsOnCall[len(fake.workerContainersArgsForCall)]
	fake.workerContainersArgsForCall = append(fake.workerContainersArgsForCall, struct {
	}{})
	stub := fake.WorkerContainersStub
	fakeReturns := fake.workerContainersReturns
	fake.recordInvocation("WorkerContainers", []interface{}{})
	fake.workerContainersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersCallCount() int {
	fake.workerContainersMutex.RLock()
	defer fake.workerContainersMutex.RUnlock()
	return len(fake.workerContainersArgsForCall)
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersCalls(stub func() *prometheus.GaugeVec) {
	fake.workerContainersMutex.Lock()
	defer fake.workerContainersMutex.Unlock()
	fake.WorkerContainersStub = stub
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersReturns(result1 *prometheus.GaugeVec) {
	fake.workerContainersMutex.Lock()
	defer fake.workerContainersMutex.Unlock()
	fake.WorkerContainersStub = nil
	fake.workerContainersReturns = struct {
		result1 *prometheus.GaugeVec
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersReturnsOnCall(i int, result1 *prometheus.GaugeVec) {
	fake.workerContainersMutex.Lock()
	defer fake.workerContainersMutex.Unlock()
	fake.WorkerContainersStub = nil
	if fake.workerContainersReturnsOnCall == nil {
		fake.workerContainersReturnsOnCall = make(map[int]struct {
			result1 *prometheus.GaugeVec
		})
	}
	fake.workerContainersReturnsOnCall[i] = struct {
		result1 *prometheus.GaugeVec
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersLabels() map[string]map[string]prometheus.Labels {
	fake.workerContainersLabelsMutex.Lock()
	ret, specificReturn := fake.workerContainersLabelsReturnsOnCall[len(fake.workerContainersLabelsArgsForCall)]
	fake.workerContainersLabelsArgsForCall = append(fake.workerContainersLabelsArgsForCall, struct {
	}{})
	stub := fake.WorkerContainersLabelsStub
	fakeReturns := fake.workerContainersLabelsReturns
	fake.recordInvocation("WorkerContainersLabels", []interface{}{})
	fake.workerContainersLabelsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersLabelsCallCount() int {
	fake.workerContainersLabelsMutex.RLock()
	defer fake.workerContainersLabelsMutex.RUnlock()
	return len(fake.workerContainersLabelsArgsForCall)
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersLabelsCalls(stub func() map[string]map[string]prometheus.Labels) {
	fake.workerContainersLabelsMutex.Lock()
	defer fake.workerContainersLabelsMutex.Unlock()
	fake.WorkerContainersLabelsStub = stub
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersLabelsReturns(result1 map[string]map[string]prometheus.Labels) {
	fake.workerContainersLabelsMutex.Lock()
	defer fake.workerContainersLabelsMutex.Unlock()
	fake.WorkerContainersLabelsStub = nil
	fake.workerContainersLabelsReturns = struct {
		result1 map[string]map[string]prometheus.Labels
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerContainersLabelsReturnsOnCall(i int, result1 map[string]map[string]prometheus.Labels) {
	fake.workerContainersLabelsMutex.Lock()
	defer fake.workerContainersLabelsMutex.Unlock()
	fake.WorkerContainersLabelsStub = nil
	if fake.workerContainersLabelsReturnsOnCall == nil {
		fake.workerContainersLabelsReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]prometheus.Labels
		})
	}
	fake.workerContainersLabelsReturnsOnCall[i] = struct {
		result1 map[string]map[string]prometheus.Labels
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasks() *prometheus.GaugeVec {
	fake.workerTasksMutex.Lock()
	ret, specificReturn := fake.workerTasksReturnsOnCall[len(fake.workerTasksArgsForCall)]
	fake.workerTasksArgsForCall = append(fake.workerTasksArgsForCall, struct {
	}{})
	stub := fake.WorkerTasksStub
	fakeReturns := fake.workerTasksReturns
	fake.recordInvocation("WorkerTasks", []interface{}{})
	fake.workerTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksCallCount() int {
	fake.workerTasksMutex.RLock()
	defer fake.workerTasksMutex.RUnlock()
	return len(fake.workerTasksArgsForCall)
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksCalls(stub func() *prometheus.GaugeVec) {
	fake.workerTasksMutex.Lock()
	defer fake.workerTasksMutex.Unlock()
	fake.WorkerTasksStub = stub
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksReturns(result1 *prometheus.GaugeVec) {
	fake.workerTasksMutex.Lock()
	defer fake.workerTasksMutex.Unlock()
	fake.WorkerTasksStub = nil
	fake.workerTasksReturns = struct {
		result1 *prometheus.GaugeVec
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksReturnsOnCall(i int, result1 *prometheus.GaugeVec) {
	fake.workerTasksMutex.Lock()
	defer fake.workerTasksMutex.Unlock()
	fake.WorkerTasksStub = nil
	if fake.workerTasksReturnsOnCall == nil {
		fake.workerTasksReturnsOnCall = make(map[int]struct {
			result1 *prometheus.GaugeVec
		})
	}
	fake.workerTasksReturnsOnCall[i] = struct {
		result1 *prometheus.GaugeVec
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksLabels() map[string]map[string]prometheus.Labels {
	fake.workerTasksLabelsMutex.Lock()
	ret, specificReturn := fake.workerTasksLabelsReturnsOnCall[len(fake.workerTasksLabelsArgsForCall)]
	fake.workerTasksLabelsArgsForCall = append(fake.workerTasksLabelsArgsForCall, struct {
	}{})
	stub := fake.WorkerTasksLabelsStub
	fakeReturns := fake.workerTasksLabelsReturns
	fake.recordInvocation("WorkerTasksLabels", []interface{}{})
	fake.workerTasksLabelsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksLabelsCallCount() int {
	fake.workerTasksLabelsMutex.RLock()
	defer fake.workerTasksLabelsMutex.RUnlock()
	return len(fake.workerTasksLabelsArgsForCall)
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksLabelsCalls(stub func() map[string]map[string]prometheus.Labels) {
	fake.workerTasksLabelsMutex.Lock()
	defer fake.workerTasksLabelsMutex.Unlock()
	fake.WorkerTasksLabelsStub = stub
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksLabelsReturns(result1 map[string]map[string]prometheus.Labels) {
	fake.workerTasksLabelsMutex.Lock()
	defer fake.workerTasksLabelsMutex.Unlock()
	fake.WorkerTasksLabelsStub = nil
	fake.workerTasksLabelsReturns = struct {
		result1 map[string]map[string]prometheus.Labels
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerTasksLabelsReturnsOnCall(i int, result1 map[string]map[string]prometheus.Labels) {
	fake.workerTasksLabelsMutex.Lock()
	defer fake.workerTasksLabelsMutex.Unlock()
	fake.WorkerTasksLabelsStub = nil
	if fake.workerTasksLabelsReturnsOnCall == nil {
		fake.workerTasksLabelsReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]prometheus.Labels
		})
	}
	fake.workerTasksLabelsReturnsOnCall[i] = struct {
		result1 map[string]map[string]prometheus.Labels
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumes() *prometheus.GaugeVec {
	fake.workerVolumesMutex.Lock()
	ret, specificReturn := fake.workerVolumesReturnsOnCall[len(fake.workerVolumesArgsForCall)]
	fake.workerVolumesArgsForCall = append(fake.workerVolumesArgsForCall, struct {
	}{})
	stub := fake.WorkerVolumesStub
	fakeReturns := fake.workerVolumesReturns
	fake.recordInvocation("WorkerVolumes", []interface{}{})
	fake.workerVolumesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesCallCount() int {
	fake.workerVolumesMutex.RLock()
	defer fake.workerVolumesMutex.RUnlock()
	return len(fake.workerVolumesArgsForCall)
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesCalls(stub func() *prometheus.GaugeVec) {
	fake.workerVolumesMutex.Lock()
	defer fake.workerVolumesMutex.Unlock()
	fake.WorkerVolumesStub = stub
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesReturns(result1 *prometheus.GaugeVec) {
	fake.workerVolumesMutex.Lock()
	defer fake.workerVolumesMutex.Unlock()
	fake.WorkerVolumesStub = nil
	fake.workerVolumesReturns = struct {
		result1 *prometheus.GaugeVec
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesReturnsOnCall(i int, result1 *prometheus.GaugeVec) {
	fake.workerVolumesMutex.Lock()
	defer fake.workerVolumesMutex.Unlock()
	fake.WorkerVolumesStub = nil
	if fake.workerVolumesReturnsOnCall == nil {
		fake.workerVolumesReturnsOnCall = make(map[int]struct {
			result1 *prometheus.GaugeVec
		})
	}
	fake.workerVolumesReturnsOnCall[i] = struct {
		result1 *prometheus.GaugeVec
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesLabels() map[string]map[string]prometheus.Labels {
	fake.workerVolumesLabelsMutex.Lock()
	ret, specificReturn := fake.workerVolumesLabelsReturnsOnCall[len(fake.workerVolumesLabelsArgsForCall)]
	fake.workerVolumesLabelsArgsForCall = append(fake.workerVolumesLabelsArgsForCall, struct {
	}{})
	stub := fake.WorkerVolumesLabelsStub
	fakeReturns := fake.workerVolumesLabelsReturns
	fake.recordInvocation("WorkerVolumesLabels", []interface{}{})
	fake.workerVolumesLabelsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesLabelsCallCount() int {
	fake.workerVolumesLabelsMutex.RLock()
	defer fake.workerVolumesLabelsMutex.RUnlock()
	return len(fake.workerVolumesLabelsArgsForCall)
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesLabelsCalls(stub func() map[string]map[string]prometheus.Labels) {
	fake.workerVolumesLabelsMutex.Lock()
	defer fake.workerVolumesLabelsMutex.Unlock()
	fake.WorkerVolumesLabelsStub = stub
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesLabelsReturns(result1 map[string]map[string]prometheus.Labels) {
	fake.workerVolumesLabelsMutex.Lock()
	defer fake.workerVolumesLabelsMutex.Unlock()
	fake.WorkerVolumesLabelsStub = nil
	fake.workerVolumesLabelsReturns = struct {
		result1 map[string]map[string]prometheus.Labels
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) WorkerVolumesLabelsReturnsOnCall(i int, result1 map[string]map[string]prometheus.Labels) {
	fake.workerVolumesLabelsMutex.Lock()
	defer fake.workerVolumesLabelsMutex.Unlock()
	fake.WorkerVolumesLabelsStub = nil
	if fake.workerVolumesLabelsReturnsOnCall == nil {
		fake.workerVolumesLabelsReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]prometheus.Labels
		})
	}
	fake.workerVolumesLabelsReturnsOnCall[i] = struct {
		result1 map[string]map[string]prometheus.Labels
	}{result1}
}

func (fake *FakePrometheusGarbageCollectable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.containerJobCollectorLabelsMutex.RLock()
	defer fake.containerJobCollectorLabelsMutex.RUnlock()
	fake.droppedContainerMutex.RLock()
	defer fake.droppedContainerMutex.RUnlock()
	fake.workerContainersMutex.RLock()
	defer fake.workerContainersMutex.RUnlock()
	fake.workerContainersLabelsMutex.RLock()
	defer fake.workerContainersLabelsMutex.RUnlock()
	fake.workerTasksMutex.RLock()
	defer fake.workerTasksMutex.RUnlock()
	fake.workerTasksLabelsMutex.RLock()
	defer fake.workerTasksLabelsMutex.RUnlock()
	fake.workerVolumesMutex.RLock()
	defer fake.workerVolumesMutex.RUnlock()
	fake.workerVolumesLabelsMutex.RLock()
	defer fake.workerVolumesLabelsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePrometheusGarbageCollectable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ emitter.PrometheusGarbageCollectable = new(FakePrometheusGarbageCollectable)
